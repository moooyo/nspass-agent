package iptables

import (
	"bytes"
	"fmt"
	"sort"
	"strings"
	"text/template"
	"time"
)

// TemplateManager 管理所有iptables相关的模板
type TemplateManager struct {
	iptablesTemplate *template.Template
	ruleTemplate     *template.Template
	chainTemplate    *template.Template
}

// NewTemplateManager 创建模板管理器
func NewTemplateManager() (*TemplateManager, error) {
	tm := &TemplateManager{}

	// 初始化iptables文件模板
	iptablesTmpl, err := template.New("iptables").Funcs(template.FuncMap{
		"sortChains": func(chains map[string]*IPTablesChain) []string {
			names := make([]string, 0, len(chains))
			for name := range chains {
				names = append(names, name)
			}
			sort.Strings(names)
			return names
		},
		"formatChain": func(chain *IPTablesChain) string {
			return fmt.Sprintf(":%s %s %s", chain.Name, chain.Policy, chain.Counters)
		},
		"list": func(items ...string) []string {
			return items
		},
	}).Parse(iptablesFileTemplate)
	if err != nil {
		return nil, fmt.Errorf("解析iptables模板失败: %w", err)
	}
	tm.iptablesTemplate = iptablesTmpl

	// 初始化规则模板
	ruleTmpl, err := template.New("rule").Funcs(template.FuncMap{
		"action": func(action string) string {
			if action == "insert" {
				return "-I"
			}
			return "-A"
		},
		"comment": func(ruleID string) string {
			return fmt.Sprintf("-m comment --comment \"NSPass:%s\"", ruleID)
		},
	}).Parse(ruleTemplate)
	if err != nil {
		return nil, fmt.Errorf("解析规则模板失败: %w", err)
	}
	tm.ruleTemplate = ruleTmpl

	// 初始化链模板
	chainTmpl, err := template.New("chain").Parse(chainTemplate)
	if err != nil {
		return nil, fmt.Errorf("解析链模板失败: %w", err)
	}
	tm.chainTemplate = chainTmpl

	return tm, nil
}

// TemplateData 用于模板渲染的数据结构
type TemplateData struct {
	Tables      map[string]*IPTablesTable
	Generated   time.Time
	ChainPrefix string
}

// RuleTemplateData 用于规则模板的数据结构
type RuleTemplateData struct {
	Action string
	Chain  string
	Rule   string
	ID     string
}

// ChainTemplateData 用于链模板的数据结构
type ChainTemplateData struct {
	Name     string
	Policy   string
	Counters string
}

// GenerateIPTablesContent 使用模板生成iptables-save格式内容
func (tm *TemplateManager) GenerateIPTablesContent(tables map[string]*IPTablesTable, chainPrefix string) (string, error) {
	data := TemplateData{
		Tables:      tables,
		Generated:   time.Now(),
		ChainPrefix: chainPrefix,
	}

	var buf bytes.Buffer
	if err := tm.iptablesTemplate.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("模板执行失败: %w", err)
	}

	return buf.String(), nil
}

// GenerateRule 使用模板生成单个规则字符串
func (tm *TemplateManager) GenerateRule(rule *Rule) (string, error) {
	data := RuleTemplateData{
		Action: rule.Action,
		Chain:  rule.Chain,
		Rule:   rule.Rule,
		ID:     rule.ID,
	}

	var buf bytes.Buffer
	if err := tm.ruleTemplate.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("规则模板执行失败: %w", err)
	}

	return strings.TrimSpace(buf.String()), nil
}

// GenerateChain 使用模板生成链定义
func (tm *TemplateManager) GenerateChain(chain *IPTablesChain) (string, error) {
	data := ChainTemplateData{
		Name:     chain.Name,
		Policy:   chain.Policy,
		Counters: chain.Counters,
	}

	var buf bytes.Buffer
	if err := tm.chainTemplate.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("链模板执行失败: %w", err)
	}

	return strings.TrimSpace(buf.String()), nil
}

// iptables-save 文件模板
const iptablesFileTemplate = `# Generated by NSPass Agent at {{ .Generated.Format "2006-01-02 15:04:05" }}
# Chain prefix: {{ .ChainPrefix }}
{{- range $tableName := (list "raw" "mangle" "nat" "filter") }}
{{- $table := index $.Tables $tableName }}
{{- if $table }}

*{{ $table.Name }}
{{- range $chainName := (sortChains $table.Chains) }}
{{- $chain := index $table.Chains $chainName }}
{{ formatChain $chain }}
{{- end }}
{{- range $table.Rules }}
{{ . }}
{{- end }}
COMMIT
{{- end }}
{{- end }}`

// 单个规则模板
const ruleTemplate = `{{ action .Action }} {{ .Chain }} {{ .Rule }} {{ comment .ID }}`

// 链定义模板
const chainTemplate = `:{{ .Name }} {{ .Policy }} {{ .Counters }}`
